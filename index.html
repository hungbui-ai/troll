<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sword Master Pro - Realtime Interaction</title>
    <style>
        body { margin: 0; overflow: hidden; background: radial-gradient(circle, #1a1a2e 0%, #000000 100%); font-family: 'Segoe UI', sans-serif; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px);
            padding: 20px; border-radius: 15px; border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 8px 32px 0 rgba(0,0,0,0.8); pointer-events: none;
        }
        .status-pill { display: inline-block; padding: 4px 12px; border-radius: 20px; background: #00ff88; color: #000; font-weight: bold; margin-bottom: 10px; font-size: 12px; }
        #video-preview { position: absolute; top: 20px; right: 20px; width: 180px; border-radius: 12px; border: 2px solid #00ff88; transform: scaleX(-1); }
        .hint { font-size: 13px; color: #aaa; margin-top: 10px; }
        b { color: #00ff88; }
    </style>
</head>
<body>

<div id="ui">
    <div id="status-tag" class="status-pill">ĐANG CHỜ CAMERA...</div>
    <div style="font-size: 18px; font-weight: bold;">SWORD COMMANDER</div>
    <div class="hint">Cử chỉ hiện tại: <b id="gesture-text">Bình thường</b></div>
    <div class="hint">
        • <b>Xòe tay:</b> Orbit Mode (Vây quanh)<br>
        • <b>Nắm tay:</b> Attack Formation (Tập trung)<br>
        • <b>Vung tay nhanh:</b> Scatter (Tản loạn)
    </div>
</div>

<video id="video-preview" autoplay playsinline></video>

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
import * as THREE from 'three';
import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

/** --- KHỞI TẠO THREE.JS --- **/
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// Tạo thanh kiếm chi tiết hơn (Lưỡi + Chuôi)
function createSwordGeometry() {
    const group = new THREE.Group();
    // Lưỡi kiếm
    const bladeGeo = new THREE.BoxGeometry(0.08, 1.2, 0.02);
    const bladeMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.5 });
    // Chuôi kiếm
    const guardGeo = new THREE.BoxGeometry(0.4, 0.05, 0.05);
    const handleGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.3);
    
    const blade = new THREE.Mesh(bladeGeo, bladeMat);
    const guard = new THREE.Mesh(guardGeo, bladeMat);
    const handle = new THREE.Mesh(handleGeo, bladeMat);
    
    blade.position.y = 0.6;
    handle.position.y = -0.15;
    
    const merged = new THREE.Group();
    merged.add(blade, guard, handle);
    return merged;
}

// Chuyển Group thành một Geometry duy nhất để dùng InstancedMesh
const swordGeom = new THREE.BoxGeometry(0.1, 1.5, 0.05); // Đơn giản hóa để tối ưu Instancing
const swordMat = new THREE.MeshStandardMaterial({ 
    color: 0xffffff, 
    emissive: 0x00ccff, 
    emissiveIntensity: 2,
    metalness: 1,
    roughness: 0.1
});

const COUNT = 1000;
const iMesh = new THREE.InstancedMesh(swordGeom, swordMat, COUNT);
scene.add(iMesh);

const swords = Array.from({ length: COUNT }, () => ({
    pos: new THREE.Vector3((Math.random()-0.5)*40, (Math.random()-0.5)*40, (Math.random()-0.5)*40),
    vel: new THREE.Vector3(),
    acc: new THREE.Vector3(),
    speed: 0.4 + Math.random() * 0.4
}));

const light = new THREE.PointLight(0x00ffff, 500);
scene.add(light, new THREE.AmbientLight(0x222222));
camera.position.z = 25;

/** --- LOGIC NHẬN DIỆN CỬ CHỈ CẢI TIẾN --- **/
let targetPos = new THREE.Vector3(0, 0, 0);
let isGrip = false;
let handLandmarker;

async function setupDetection() {
    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
    handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
        runningMode: "VIDEO", numHands: 1
    });
    
    const video = document.getElementById("video-preview");
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    video.srcObject = stream;
    video.onloadeddata = predict;
    document.getElementById("status-tag").innerText = "READY";
}

function predict() {
    const video = document.getElementById("video-preview");
    const result = handLandmarker.detectForVideo(video, performance.now());
    
    if (result.landmarks && result.landmarks[0]) {
        const pts = result.landmarks[0];
        // Tâm lòng bàn tay
        targetPos.x = (0.5 - pts[9].x) * 45;
        targetPos.y = (0.5 - pts[9].y) * 30;

        // Thuật toán nhận diện nắm tay: So sánh đầu ngón tay với khớp gốc
        // Nếu khoảng cách trung bình của các đầu ngón tới cổ tay nhỏ -> Nắm
        const wrist = pts[0];
        const fingers = [8, 12, 16, 20];
        let totalDist = 0;
        fingers.forEach(i => {
            totalDist += Math.hypot(pts[i].x - wrist.x, pts[i].y - wrist.y);
        });
        
        isGrip = totalDist < 0.6; // Ngưỡng độ gập
        document.getElementById("gesture-text").innerText = isGrip ? "Attack Formation (Nắm)" : "Orbit Mode (Xòe)";
    }
    requestAnimationFrame(predict);
}

/** --- RENDER LOOP --- **/
const dummy = new THREE.Object3D();
function animate() {
    light.position.lerp(targetPos, 0.1);
    
    for (let i = 0; i < COUNT; i++) {
        const s = swords[i];
        const force = new THREE.Vector3();
        
        if (isGrip) {
            // Nắm tay: Kiếm hội tụ về một vòng tròn quanh tay
            const angle = (i / COUNT) * Math.PI * 2;
            const t = new THREE.Vector3(
                targetPos.x + Math.cos(angle) * 3,
                targetPos.y + Math.sin(angle) * 3,
                targetPos.z
            );
            force.subVectors(t, s.pos).multiplyScalar(0.05);
        } else {
            // Xòe tay: Bay quỹ đạo xoắn ốc
            const dir = new THREE.Vector3().subVectors(targetPos, s.pos);
            const dist = dir.length();
            const orbit = new THREE.Vector3(-dir.y, dir.x, 0).normalize().multiplyScalar(2);
            force.add(dir.normalize().multiplyScalar(dist * 0.02)).add(orbit);
        }

        s.vel.add(force).clampLength(0, s.speed);
        s.pos.add(s.vel);

        dummy.position.copy(s.pos);
        dummy.lookAt(s.pos.clone().add(s.vel));
        dummy.updateMatrix();
        iMesh.setMatrixAt(i, dummy.matrix);
    }
    
    iMesh.instanceMatrix.needsUpdate = true;
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}

setupDetection();
animate();

window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};
</script>
</body>
</html>
