<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Sword Storm - MediaPipe & Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        canvas { display: block; }
        #info {
            position: absolute; top: 10px; left: 10px; color: #00ff00;
            background: rgba(0,0,0,0.7); padding: 10px; pointer-events: none;
            border-radius: 5px; font-size: 12px;
        }
        #video-container { position: absolute; bottom: 10px; right: 10px; width: 150px; border: 2px solid #555; }
        #webcam { width: 100%; transform: scaleX(-1); }
    </style>
</head>
<body>

<div id="info">
    <b>SWORD STORM DEMO</b><br>
    Trạng thái: <span id="status">Đang khởi tạo...</span><br>
    Cử chỉ: <span id="gesture">N/A</span><br>
    - Xòe tay: Orbit (Xoay quanh)<br>
    - Nắm tay: Formation (Hội tụ)<br>
    - Di chuyển nhanh: Scatter (Tán loạn)
</div>

<div id="video-container">
    <video id="webcam" autoplay playsinline></video>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
</script>

<script type="module">
import * as THREE from 'three';

/** --- CẤU HÌNH --- **/
const SWORD_COUNT = 2000;
const STATES = { SCATTER: 'SCATTER', ORBIT: 'ORBIT', FORMATION: 'FORMATION' };
let currentState = STATES.ORBIT;

/** --- HAND TRACKING MODULE (MEDIAPIPE) --- **/
import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

let handLandmarker;
let lastVideoTime = -1;
let handPos = new THREE.Vector3(0, 0, 0);
let isGrip = false;

async function initHandTracking() {
    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
    handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
        runningMode: "VIDEO", numHands: 1
    });
    startCamera();
}

async function startCamera() {
    const video = document.getElementById("webcam");
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    video.srcObject = stream;
    video.addEventListener("loadeddata", predictWebcam);
}

async function predictWebcam() {
    const video = document.getElementById("webcam");
    if (lastVideoTime !== video.currentTime) {
        lastVideoTime = video.currentTime;
        const result = handLandmarker.detectForVideo(video, performance.now());
        if (result.landmarks && result.landmarks.length > 0) {
            processHandData(result.landmarks[0]);
        }
    }
    requestAnimationFrame(predictWebcam);
}

function processHandData(landmarks) {
    // Lấy tọa độ lòng bàn tay (điểm số 9) và chuẩn hóa sang không gian 3D
    const palm = landmarks[9];
    handPos.x = (0.5 - palm.x) * 40; // Đảo trục X vì webcam bị ngược
    handPos.y = (0.5 - palm.y) * 25;
    
    // Check cử chỉ: Tính khoảng cách ngón cái (4) và ngón út (20)
    const dist = Math.hypot(landmarks[4].x - landmarks[20].x, landmarks[4].y - landmarks[20].y);
    isGrip = dist < 0.12; 
    
    currentState = isGrip ? STATES.FORMATION : STATES.ORBIT;
    document.getElementById("gesture").innerText = isGrip ? "Nắm tay (Formation)" : "Xòe tay (Orbit)";
    document.getElementById("status").innerText = "Đang điều khiển";
}

/** --- SWORD SYSTEM MODULE (THREE.JS) --- **/
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Tạo Geometery cho thanh kiếm (Dùng Cone mỏng để giả lập lưỡi kiếm)
const geometry = new THREE.ConeGeometry(0.05, 1.2, 4);
geometry.rotateX(Math.PI / 2); // Để kiếm hướng về phía trước
const material = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.2 });
const instancedMesh = new THREE.InstancedMesh(geometry, material, SWORD_COUNT);
scene.add(instancedMesh);

// Data cho từng thanh kiếm
const swords = [];
const dummy = new THREE.Object3D();

for (let i = 0; i < SWORD_COUNT; i++) {
    swords.push({
        position: new THREE.Vector3((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50),
        velocity: new THREE.Vector3(),
        acceleration: new THREE.Vector3(),
        maxSpeed: 0.5 + Math.random() * 0.5,
        maxForce: 0.05 + Math.random() * 0.05
    });
}

// Ánh sáng
const light = new THREE.PointLight(0x00ffff, 1000, 100);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040));

camera.position.z = 30;

/** --- LOOP CẬP NHẬT --- **/
function animate() {
    requestAnimationFrame(animate);

    light.position.copy(handPos);

    for (let i = 0; i < SWORD_COUNT; i++) {
        const s = swords[i];
        const steer = new THREE.Vector3();

        if (currentState === STATES.ORBIT) {
            // Lực hút xoay quanh tay
            const desired = new THREE.Vector3().subVectors(handPos, s.position);
            const dist = desired.length();
            const cross = new THREE.Vector3().crossVectors(desired, new THREE.Vector3(0, 1, 0)).normalize();
            
            desired.normalize().multiplyScalar(dist * 0.05); // Hút vào
            steer.add(desired).add(cross.multiplyScalar(0.8)); // Xoay vòng
        } 
        else if (currentState === STATES.FORMATION) {
            // Tập trung vào một điểm cố định (Formation tròn)
            const angle = (i / SWORD_COUNT) * Math.PI * 2;
            const target = new THREE.Vector3(
                handPos.x + Math.cos(angle) * 5,
                handPos.y + Math.sin(angle) * 5,
                handPos.z
            );
            const desired = new THREE.Vector3().subVectors(target, s.position);
            steer.add(desired.multiplyScalar(0.1));
        }

        // Vật lý cơ bản
        s.velocity.add(steer).clampLength(0, s.maxSpeed);
        s.position.add(s.velocity);

        // Cập nhật Instanced Matrix
        dummy.position.copy(s.position);
        if (s.velocity.length() > 0.01) {
            const lookTarget = s.position.clone().add(s.velocity);
            dummy.lookAt(lookTarget);
        }
        dummy.updateMatrix();
        instancedMesh.setMatrixAt(i, dummy.matrix);
    }

    instancedMesh.instanceMatrix.needsUpdate = true;
    renderer.render(scene, camera);
}

// Khởi chạy
initHandTracking();
animate();

// Resize xử lý
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
